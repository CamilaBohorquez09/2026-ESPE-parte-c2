# Proyecto de Pruebas Unitarias – Conversación Consolidada

Este documento recopila y organiza **toda la conversación técnica** mantenida para el desarrollo del proyecto de **pruebas unitarias de la clase `Order`**, basada en la especificación proporcionada.

---

## 1. Objetivo del proyecto

Desarrollar un conjunto completo de **pruebas unitarias** para la clase `Order`, verificando el correcto funcionamiento del método:

```java
void addItem(Item item)
```

Las pruebas validan:

* Estado inicial de la orden
* Inserción correcta de ítems
* Reglas de negocio
* Manejo de excepciones
* Casos límite

---

## 2. Estructura del proyecto

```
src
├── main
│   └── java
│       └── es.upm.grise.profundizacion.order
│           ├── Item.java
│           ├── ItemImpl.java
│           ├── Order.java
│           ├── Product.java
│           └── IncorrectItemException.java
└── test
    └── java
        └── es.upm.grise.profundizacion.order
            └── OrderTest.java
```

---

## 3. Clases del proyecto

### 3.1 Item.java (interfaz)

```java
package es.upm.grise.profundizacion.order;

public interface Item {
    Product getProduct();
    int getQuantity();
    void setQuantity(int i);
    double getPrice();
}
```

---

### 3.2 ItemImpl.java

```java
package es.upm.grise.profundizacion.order;

public class ItemImpl implements Item {

    private Product product;
    private double price;
    private int quantity;

    public ItemImpl(Product product, double price, int quantity) {
        this.product = product;
        this.price = price;
        this.quantity = quantity;
    }

    @Override
    public Product getProduct() {
        return product;
    }

    @Override
    public int getQuantity() {
        return quantity;
    }

    @Override
    public void setQuantity(int i) {
        this.quantity = i;
    }

    @Override
    public double getPrice() {
        return price;
    }
}
```

---

### 3.3 Product.java

```java
package es.upm.grise.profundizacion.order;

public class Product {

    long id;

    void setId(long id) {
        this.id = id;
    }

    long getId() {
        return id;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Product other = (Product) obj;
        return id == other.id;
    }
}
```

---

### 3.4 IncorrectItemException.java

```java
package es.upm.grise.profundizacion.order;

public class IncorrectItemException extends RuntimeException {
    public IncorrectItemException(String message) {
        super(message);
    }
}
```

---

### 3.5 Order.java

```java
package es.upm.grise.profundizacion.order;

import java.util.ArrayList;
import java.util.Collection;

public class Order {

    private Collection<Item> items;

    public Order() {
        this.items = new ArrayList<>();
    }

    public void addItem(Item item) {

        if (item == null) {
            throw new RuntimeException("Item nulo");
        }

        if (item.getPrice() < 0) {
            throw new IncorrectItemException("Precio negativo");
        }

        if (item.getQuantity() <= 0) {
            throw new IncorrectItemException("Cantidad incorrecta");
        }

        for (Item existingItem : items) {
            if (existingItem.getProduct().equals(item.getProduct())
                    && existingItem.getPrice() == item.getPrice()) {

                existingItem.setQuantity(
                        existingItem.getQuantity() + item.getQuantity());
                return;
            }
        }

        items.add(item);
    }

    public Collection<Item> getItems() {
        return this.items;
    }
}
```

---
### Pregunta 2

**Usuario:**

> La estructura del proyecto está definida así.

**Respuesta:**
Se validó que la estructura `src/main/java` y `src/test/java` era correcta, siguiendo buenas prácticas de proyectos Java con JUnit, y se confirmó que `OrderTest` debía ubicarse en el mismo paquete que `Order`.

---

### Pregunta 3

**Usuario:**

> Así mantengo mi OrderTest.java (smoke test).

**Respuesta:**
Se confirmó que el *smoke test* es válido como primer paso, ya que verifica que el entorno de pruebas está correctamente configurado y que JUnit se ejecuta sin errores.

---

### Pregunta 4

**Usuario:**

> Dame las pruebas que vamos a realizar.

**Respuesta:**
Se definió el conjunto completo de pruebas unitarias:

* Creación de `Order`
* Lista inicial vacía
* Inserción válida de ítems
* Validación de precio y cantidad
* Manejo de productos repetidos (mismo precio / distinto precio)
* Caso de item nulo

Cada prueba fue identificada y justificada según la especificación.

---

### Pregunta 5

**Usuario:**

> Sí, las pruebas ya completas para ejecutarlas.

**Respuesta:**
Se entregó la clase `OrderTest.java` completa con JUnit 5, incluyendo todos los casos definidos, lista para compilar y ejecutarse.

---

### Pregunta 6

**Usuario:**

> Para todas estas pruebas debes tener completas todas estas clases (Item, Order, Product).

**Respuesta:**
Se implementaron todas las clases necesarias:

* `Item` como interfaz
* `ItemImpl` como implementación concreta
* `Product` con sobrescritura de `equals()`
* `IncorrectItemException`
* `Order` con lógica completa del método `addItem`

---

### Pregunta 7

**Usuario:**

> Haz la corrección en las pruebas.

**Respuesta:**
Se corrigieron los errores en `OrderTest.java`, tales como:

* Uso correcto de `ItemImpl`
* Creación válida de `Product`
* Pruebas de cantidad cero y negativa
* Acceso correcto a `Collection<Item>` mediante iteradores

Se entregó la versión final y funcional del test.

---

### Pregunta 8

**Usuario:**

> Toda la conversación que hemos tenido mándamela hecha conversación para copiar y pegar.

**Respuesta:**
Se consolidó todo el contenido técnico en un único documento estructurado, incluyendo código, pruebas 





